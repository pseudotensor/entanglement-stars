"""
Plotting script for the Ising HDA results.

Loads data from ising_hda_results.pkl (generated by ising_hda.py)
and produces figures for the paper.

Usage:
    python ising_hda.py          # first: run MC + save data
    python ising_hda_plot.py     # then: generate figures (fast, ~1s)
"""

import numpy as np
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
from matplotlib import rcParams
import os
import pickle
import sys

SCRIPTDIR = os.path.dirname(os.path.abspath(__file__))
DATADIR = os.path.join(SCRIPTDIR, "data")
FIGDIR = os.path.join(SCRIPTDIR, "figures")
os.makedirs(FIGDIR, exist_ok=True)

rcParams.update({
    "text.usetex": False,
    "font.family": "serif",
    "font.size": 11,
    "axes.labelsize": 13,
    "axes.titlesize": 13,
    "legend.fontsize": 10,
    "xtick.labelsize": 11,
    "ytick.labelsize": 11,
    "figure.figsize": (6, 4.5),
    "figure.dpi": 150,
    "savefig.dpi": 300,
    "savefig.bbox": "tight",
    "lines.linewidth": 1.5,
})


# ===================================================================
# Plotting functions
# ===================================================================

def plot_conductances(results_list, figdir=FIGDIR):
    """Plot conductance histogram and spatial map."""
    fig, axes = plt.subplots(1, 2, figsize=(12, 5))

    # Panel 1: Histogram
    ax = axes[0]
    colors = plt.cm.viridis(np.linspace(0.15, 0.85, len(results_list)))
    for res, c in zip(results_list, colors):
        all_k = np.concatenate([res["kappa_h"].ravel(), res["kappa_v"].ravel()])
        k_mean = all_k.mean()
        normed = all_k / k_mean
        ax.hist(normed, bins=30, alpha=0.5, color=c, density=True,
                label=fr"$\beta J={res['betaJ']:.2f}$, "
                      fr"$\xi/\ell={res['xi_over_ell']:.3f}$")
        # Gaussian overlay from sample statistics
        mu, sigma = normed.mean(), normed.std()
        x_g = np.linspace(normed.min(), normed.max(), 200)
        ax.plot(x_g, np.exp(-0.5*((x_g - mu)/sigma)**2) / (sigma * np.sqrt(2*np.pi)),
                "-", color=c, lw=1.5, alpha=0.7)
    ax.plot([], [], "-", color="gray", alpha=0.7, label="Gaussian fit")
    ax.set_xlabel(r"$\kappa_{xy} / \langle\kappa\rangle$")
    ax.set_ylabel("Density")
    ax.set_title("MI conductance distribution")
    ax.axvline(1.0, color="red", ls="--", lw=1, alpha=0.5, label="Uniform")
    ax.legend(fontsize=8)

    # Panel 2: Spatial map (use highest betaJ = strongest signal)
    ax = axes[1]
    res = results_list[-1]
    kh, kv = res["kappa_h"], res["kappa_v"]
    n_by, n_bx_m1 = kh.shape
    n_bx = n_bx_m1 + 1
    k_mean = np.concatenate([kh.ravel(), kv.ravel()]).mean()

    for by in range(n_by):
        for bx in range(n_bx - 1):
            val = kh[by, bx] / k_mean
            color = plt.cm.RdBu(0.5 + 0.5 * (val - 1.0) / max(0.3, abs(val - 1.0)))
            ax.plot([bx + 0.5, bx + 1.5], [by + 0.5, by + 0.5],
                    '-', color=color, lw=2)
    for by in range(n_by - 1):
        for bx in range(n_bx):
            val = kv[by, bx] / k_mean
            color = plt.cm.RdBu(0.5 + 0.5 * (val - 1.0) / max(0.3, abs(val - 1.0)))
            ax.plot([bx + 0.5, bx + 0.5], [by + 0.5, by + 1.5],
                    '-', color=color, lw=2)

    for by in range(n_by):
        for bx in range(n_bx):
            ax.plot(bx + 0.5, by + 0.5, 'k.', ms=3)

    ax.set_xlim(0, n_bx + 0.2)
    ax.set_ylim(0, n_by + 0.2)
    ax.set_aspect("equal")
    ax.set_xlabel("Block $x$")
    ax.set_ylabel("Block $y$")
    ax.set_title(fr"Conductance network ($\beta J={res['betaJ']:.2f}$)")

    fig.tight_layout()
    fig.savefig(os.path.join(figdir, "ising_hda_conductances.pdf"))
    plt.close(fig)
    print("  Saved ising_hda_conductances.pdf")


def plot_cometric(results_list, figdir=FIGDIR):
    """Plot emergent co-metric components showing isotropy."""
    n_res = len(results_list)
    fig, axes = plt.subplots(1, min(n_res, 3), figsize=(4.5 * min(n_res, 3), 4.5))
    if min(n_res, 3) == 1:
        axes = [axes]

    for idx, (ax, res) in enumerate(zip(axes, results_list[:3])):
        h_xx, h_yy = res["h_xx"], res["h_yy"]
        h_mean = 0.5 * (h_xx.mean() + h_yy.mean())

        ax.scatter(h_xx / h_mean, h_yy / h_mean, s=15, alpha=0.6,
                   edgecolors='none', c='steelblue')

        lims = [0.5, 1.5]
        ax.plot(lims, lims, 'r--', lw=1, alpha=0.6, label=r"$h^{xx}=h^{yy}$")

        ax.set_xlabel(r"$h^{xx}/\langle h\rangle$")
        ax.set_ylabel(r"$h^{yy}/\langle h\rangle$")
        ax.set_title(fr"$\beta J={res['betaJ']:.2f}$, "
                     fr"$\xi/\ell={res['xi_over_ell']:.3f}$")
        ax.set_xlim(lims)
        ax.set_ylim(lims)
        ax.set_aspect("equal")
        ax.legend(fontsize=8)

        ic = res["ic_results"]
        status = ("IC1: " + ("PASS" if ic["IC1_passed"] else "FAIL") + "\n" +
                  "IC2: " + ("PASS" if ic["IC2_passed"] else "FAIL") + "\n" +
                  "IC3: " + ("PASS" if ic["IC3_passed"] else "FAIL"))
        ax.text(0.05, 0.95, status, transform=ax.transAxes, fontsize=8,
                va="top", ha="left",
                bbox=dict(boxstyle="round,pad=0.3", fc="wheat", alpha=0.8))

    fig.tight_layout()
    fig.savefig(os.path.join(figdir, "ising_hda_cometric.pdf"))
    plt.close(fig)
    print("  Saved ising_hda_cometric.pdf")


def plot_remainder_scaling(scan_results, block_results, figdir=FIGDIR):
    """Plot HDA remainder norm vs xi/ell showing expected scaling."""
    fig, axes = plt.subplots(1, 2, figsize=(11, 5))

    # --- Panel 1: Block-size scan ---
    ax = axes[0]
    if len(block_results) >= 2:
        xi_ell_b = np.array([r["xi_over_ell"] for r in block_results])
        rem_b = np.array([r["rel_remainder"] for r in block_results])
        fdev_b = np.array([r["remainder_details"]["frac_dev"] for r in block_results])
        M_vals = np.array([r["M"] for r in block_results])

        order = np.argsort(xi_ell_b)
        xi_ell_b, rem_b, fdev_b = xi_ell_b[order], rem_b[order], fdev_b[order]
        M_vals_s = M_vals[order]

        ax.loglog(xi_ell_b, rem_b, 'o-', color='steelblue', ms=8, lw=2,
                  label=r"$\|R\|/\|H\|$ (bracket)")
        ax.loglog(xi_ell_b, fdev_b, 's-', color='darkorange', ms=8, lw=2,
                  label=r"$\delta\kappa/\kappa$ (fluct.)")

        for x, y, m in zip(xi_ell_b, rem_b, M_vals_s):
            ax.annotate(f"M={m}", (x, y), textcoords="offset points",
                        xytext=(8, 5), fontsize=7, color='steelblue')

        log_x = np.log(xi_ell_b)
        log_y = np.log(rem_b)
        coeffs = np.polyfit(log_x, log_y, 1)
        power_bracket = coeffs[0]
        amp = np.exp(coeffs[1])
        xi_ref = np.geomspace(xi_ell_b.min() * 0.7, xi_ell_b.max() * 1.3, 50)
        ax.loglog(xi_ref, amp * xi_ref**power_bracket, 'k--', lw=1, alpha=0.5,
                  label=fr"Fit: $(\xi/\ell)^{{{power_bracket:.2f}}}$")
        scale2 = rem_b[len(rem_b)//2] / xi_ell_b[len(xi_ell_b)//2]**2
        ax.loglog(xi_ref, scale2 * xi_ref**2, 'r:', lw=1, alpha=0.4,
                  label=r"$(\xi/\ell)^2$ (predicted)")

    betaJ_b = block_results[0]["betaJ"] if block_results else 0
    ax.set_xlabel(r"$\xi/\ell$")
    ax.set_ylabel("Remainder norm")
    ax.set_title(fr"Block-size scan ($\beta J={betaJ_b:.2f}$)")
    ax.legend(fontsize=7, loc='upper left')
    ax.grid(True, alpha=0.3, which='both')

    # --- Panel 2: Temperature scan ---
    ax = axes[1]
    betaJs = np.array([r["betaJ"] for r in scan_results])
    rem_s = np.array([r["rel_remainder"] for r in scan_results])
    fdev_s = np.array([r["remainder_details"]["frac_dev"] for r in scan_results])
    kappa_cv_s = np.array([r["ic_results"]["kappa_cv"] for r in scan_results])
    aniso_s = np.array([r["remainder_details"]["anisotropy"] for r in scan_results])

    ax.semilogy(betaJs, rem_s, 'o-', color='steelblue', ms=6, lw=1.5,
                label=r"$\|R\|/\|H\|$ (bracket)")
    ax.semilogy(betaJs, fdev_s, 's-', color='darkorange', ms=6, lw=1.5,
                label=r"$\delta\kappa/\kappa$ (fluct.)")
    ax.semilogy(betaJs, kappa_cv_s, '^-', color='green', ms=5, lw=1,
                label=r"CV($\kappa$)")
    ax.semilogy(betaJs, aniso_s, 'v-', color='purple', ms=5, lw=1,
                label="Anisotropy")

    # Signal-strength-corrected power-law overlay from block-size fit
    # R(betaJ) = amp * (xi/ell)^alpha * (betaJ_ref/betaJ)^2
    # The (betaJ_ref/betaJ)^2 factor accounts for ||H|| ~ (betaJ)^2 growth
    if len(block_results) >= 2 and len(scan_results) >= 2:
        xi_ell_b = np.array([r["xi_over_ell"] for r in block_results])
        rem_b = np.array([r["rel_remainder"] for r in block_results])
        log_x = np.log(xi_ell_b)
        log_y = np.log(rem_b)
        coeffs = np.polyfit(log_x, log_y, 1)
        alpha_fit = coeffs[0]
        amp_fit = np.exp(coeffs[1])
        betaJ_ref = block_results[0]["betaJ"]
        xi_ell_s = np.array([r["xi_over_ell"] for r in scan_results])

        R_pred = amp_fit * xi_ell_s**alpha_fit * (betaJ_ref / betaJs)**2
        # Only show in the EFT regime (xi/ell < 0.5)
        mask = xi_ell_s < 0.5
        ax.semilogy(betaJs[mask], R_pred[mask], 'k--', lw=1.2, alpha=0.5,
                    label=fr"$(\xi/\ell)^{{{alpha_fit:.1f}}} \times (\beta J_0/\beta J)^2$")

    betaJ_c = np.log(1 + np.sqrt(2)) / 2
    ax.axvline(betaJ_c, color='red', ls='--', lw=1, alpha=0.5,
               label=fr"$\beta_c J = {betaJ_c:.3f}$")

    ax.set_xlabel(r"$\beta J$")
    ax.set_ylabel("Deviation measure")
    M_s = scan_results[0]["M"] if scan_results else 0
    ax.set_title(fr"Temperature scan ($M={M_s}$)")
    ax.legend(fontsize=7)
    ax.grid(True, alpha=0.3, which='both')

    fig.tight_layout()
    fig.savefig(os.path.join(figdir, "ising_hda_remainder.pdf"))
    plt.close(fig)
    print("  Saved ising_hda_remainder.pdf")


# ===================================================================
# Main
# ===================================================================

def main():
    datapath = os.path.join(DATADIR, "ising_hda_results.pkl")
    if not os.path.exists(datapath):
        print(f"Error: {datapath} not found.")
        print("Run ising_hda.py first to generate the data.")
        sys.exit(1)

    print(f"Loading data from {datapath} ...")
    with open(datapath, "rb") as f:
        data = pickle.load(f)

    scan_results = data["scan_results"]
    block_results = data["block_results"]

    print(f"  {len(scan_results)} temperature points, "
          f"{len(block_results)} block-size points")

    print("\nGenerating figures ...")
    representative = [scan_results[i] for i in [0, 2, 5, 7]]
    plot_conductances(representative)
    plot_cometric([scan_results[i] for i in [1, 3, 6]])
    plot_remainder_scaling(scan_results, block_results)

    print(f"\nFigures saved to: {FIGDIR}")


if __name__ == "__main__":
    main()
