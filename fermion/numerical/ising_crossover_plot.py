"""
Plotting script for the Ising crossover results.

Loads data from ising_crossover_results.pkl (generated by ising_crossover.py)
and produces figures for the paper.

Usage:
    python ising_crossover.py          # first: run MC + save data
    python ising_crossover_plot.py     # then: generate figures (fast, ~1s)
"""

import numpy as np
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
from matplotlib import rcParams
import os
import pickle
import sys

SCRIPTDIR = os.path.dirname(os.path.abspath(__file__))
DATADIR = os.path.join(SCRIPTDIR, "data")
FIGDIR = os.path.join(SCRIPTDIR, "figures")
os.makedirs(FIGDIR, exist_ok=True)

rcParams.update({
    "text.usetex": False,
    "font.family": "serif",
    "font.size": 11,
    "axes.labelsize": 13,
    "axes.titlesize": 13,
    "legend.fontsize": 10,
    "xtick.labelsize": 11,
    "ytick.labelsize": 11,
    "figure.figsize": (6, 4.5),
    "figure.dpi": 150,
    "savefig.dpi": 300,
    "savefig.bbox": "tight",
    "lines.linewidth": 1.5,
})

# Physical constants
M = 8
L = 64
BETA_C = np.log(1.0 + np.sqrt(2.0)) / 2.0


def xi_ht(beta, J=1.0):
    """High-temperature decay scale for T > Tc.

    Leading-order HT correlator: <s_0 s_r>_c ~ tanh(beta*J)^r, giving
    xi^{-1} = -ln(tanh(beta*J)).  This short-range scale controls the
    MI between adjacent blocks and agrees with the MC-measured decay rate.
    """
    if beta * J >= BETA_C:
        return np.inf
    return -1.0 / np.log(np.tanh(beta * J))


# Note: older code used `xi_onsager = xi_ht` here, but that name is
# misleading (this is the HT decay length, not the Onsager xi).
# Plots in this script use xi_2d_exact() for the true Onsager length.
xi_ht_scale = xi_ht


def xi_2d_exact(beta, J=1.0):
    """Exact asymptotic 2D Onsager correlation length for T > Tc.

    From the transfer-matrix eigenvalue gap: xi^{-1} = 2(K* - K)
    = -ln(tanh(beta*J)) - 2*beta*J.  Diverges at beta_c.
    """
    K = beta * J
    if K >= BETA_C:
        return np.inf
    inv_xi = -np.log(np.tanh(K)) - 2.0 * K
    if inv_xi <= 0:
        return np.inf
    return 1.0 / inv_xi


def _cross_block_geometry(M, block_sep=1):
    """Precompute Manhattan distances and path counts for cross-block pairs.

    Block 0 occupies x in [0, M), block at separation `block_sep`
    occupies x in [block_sep*M, (block_sep+1)*M).  Both have y in [0, M).
    Returns (d1_arr, npath_arr) arrays of length M^4.
    """
    from math import comb as mcomb
    d1_list = []
    np_list = []
    x0 = block_sep * M
    for xa in range(M):
        for ya in range(M):
            for xb in range(x0, x0 + M):
                for yb in range(M):
                    dx = xb - xa          # > 0
                    dy = abs(yb - ya)     # >= 0
                    d1 = dx + dy
                    d1_list.append(d1)
                    np_list.append(mcomb(d1, dx))
    return (np.array(d1_list, dtype=np.float64),
            np.array(np_list, dtype=np.float64))


def compute_kappa_ht(betas, M=8, J=1.0, block_sep=1):
    """Predicted kappa from the leading-order high-T expansion.

    Models <s_i s_j> = C(d1, |dx|) * tanh(beta*J)^d1, where
    d1 = |dx| + |dy| is the Manhattan distance and C(d1, |dx|) is the
    number of shortest lattice paths (binomial coefficient).
    Zero free parameters.  `block_sep` is the block separation (1=NN, 2=NNN).
    """
    d1_arr, npath_arr = _cross_block_geometry(M, block_sep)

    kappa = np.zeros(len(betas))
    for i, beta in enumerate(betas):
        t = np.tanh(beta * J)
        C = np.sum(npath_arr * t ** d1_arr)
        kappa[i] = C ** 2 / (2.0 * M ** 4)
    return kappa


def compute_R_block(betas, M=8, J=1.0):
    """Non-locality ratio R from block-sum model with sqrt(path count).

    Uses the leading-order HT site-level correlator tanh(beta*J)^d1
    (NOT exp(-d1/xi_2D), which would double-count path entropy).
    The sqrt(binomial) path count models incoherent summation of shortest
    lattice paths.  Zero free parameters.
    """
    d1_nn, np_nn = _cross_block_geometry(M, block_sep=1)
    d1_nnn, np_nnn = _cross_block_geometry(M, block_sep=2)
    sqrt_np_nn = np.sqrt(np_nn)
    sqrt_np_nnn = np.sqrt(np_nnn)

    R = np.zeros(len(betas))
    for i, beta in enumerate(betas):
        t = np.tanh(beta * J)
        if t < 1e-12:
            R[i] = np.nan
            continue
        t_arr_nn = t ** d1_nn
        t_arr_nnn = t ** d1_nnn
        C_nn = np.sum(sqrt_np_nn * t_arr_nn)
        C_nnn = np.sum(sqrt_np_nnn * t_arr_nnn)
        if C_nn < 1e-30:
            R[i] = np.nan
            continue
        R[i] = (C_nnn / C_nn) ** 2
    return R


def make_plots(results):
    betas = np.array([r["beta"] for r in results])
    kappa_nn = np.array([r["kappa_nn"] for r in results])
    R_axis = np.array([r["R_axis"] for r in results])
    sigma = np.array([r["sigma"] for r in results])
    aniso = np.array([r["aniso"] for r in results])

    # -----------------------------------------------------------
    # Correlation length: use the exact Onsager 2D formula everywhere.
    # This is the standard definition; it diverges at beta_c and
    # governs the block-block correlator at separations O(ell).
    # -----------------------------------------------------------
    xi_2d = np.array([xi_2d_exact(b) for b in betas])
    xi_ell = xi_2d / M          # THE x-axis for all plots

    # Block-level MC extraction (for Figure 1 confirmation only)
    xi_block = np.zeros(len(results))
    for i, r in enumerate(results):
        C_mat = r["C"]
        ratio = C_mat[1, 0] / C_mat[0, 0]
        if 0 < ratio < 1:
            xi_block[i] = -M / np.log(ratio)
        else:
            xi_block[i] = np.inf
    xi_block_ell = xi_block / M

    reliable = (kappa_nn > 1e-2) & (R_axis < 1.0) & (R_axis > 0)

    # --- Figure 1: xi/ell vs beta ---
    fig, ax = plt.subplots(figsize=(6, 4.5))

    # Exact 2D Onsager correlation length (smooth curve)
    beta_fine_xi = np.linspace(0.05, BETA_C - 0.001, 500)
    xi_2d_fine = np.array([xi_2d_exact(b) for b in beta_fine_xi])
    xi_2d_ell_fine = xi_2d_fine / M
    m2d = np.isfinite(xi_2d_ell_fine)
    ax.plot(beta_fine_xi[m2d], xi_2d_ell_fine[m2d], "-", color="C3", lw=2,
            label=r"$\xi/\ell$ (Onsager exact)")

    # MC measured: block-level extraction (confirmation)
    ax.plot(betas, xi_block_ell, "s", color="C1", ms=5, alpha=0.7,
            label=r"$\xi/\ell$ (MC, block-level)")

    ax.axhline(1.0, ls="--", color="gray", lw=1, label=r"$\xi/\ell = 1$")
    ax.axvline(BETA_C, ls=":", color="red", lw=1,
               label=rf"$\beta_c = {BETA_C:.4f}$")
    ax.axhspan(0, 1.0, alpha=0.07, color="green")
    ax.text(0.20, 0.85, "EFT regime\n" + r"$\xi < \ell$",
            fontsize=9, color="green", ha="center", va="top")
    ax.set_xlabel(r"$\beta J$")
    ax.set_ylabel(r"$\xi / \ell$")
    ax.set_title("Correlation length ratio vs inverse temperature")
    ax.set_yscale("log")
    ax.set_ylim(bottom=0.01, top=30)
    ax.legend(loc="upper left", fontsize=9)
    ax.grid(True, alpha=0.3)
    fig.savefig(os.path.join(FIGDIR, "ising_crossover_xi.pdf"))
    plt.close(fig)
    print("  Saved ising_crossover_xi.pdf")

    # --- High-T expansion model for kappa_NN (zero free parameters) ---
    kappa_ht_data = compute_kappa_ht(betas, M)

    # Fine grid for smooth curve (parametrised by beta, then mapped to xi_2D)
    beta_fine = np.linspace(0.05, BETA_C - 0.003, 200)
    kappa_ht_fine = compute_kappa_ht(beta_fine, M)
    xi_2d_fine_cond = np.array([xi_2d_exact(b) for b in beta_fine])

    # Check agreement
    ratios = kappa_nn / kappa_ht_data
    print(f"  HT model: MC/HT ratio = {np.mean(ratios):.3f} "
          f"+/- {np.std(ratios):.3f}  "
          f"(range {ratios.min():.3f} -- {ratios.max():.3f})")

    # --- Figure 2: NN conductance ---
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(11, 4.5))

    # Left panel: kappa vs beta
    ax1.plot(betas, kappa_nn, "o", color="C0", ms=5, label="MC")
    ax1.plot(beta_fine, kappa_ht_fine, "-", color="C3", lw=1.5,
             label="Leading-order HT")
    ax1.axvline(BETA_C, ls=":", color="red", lw=1,
                label=rf"$\beta_c$")
    ax1.set_xlabel(r"$\beta J$")
    ax1.set_ylabel(r"$\kappa_{\rm NN}$")
    ax1.set_title(r"Mean NN conductance vs $\beta$")
    ax1.set_yscale("log")
    ax1.legend(fontsize=9)
    ax1.grid(True, alpha=0.3)

    # Right panel: kappa vs xi_2D/ell (log-log)
    si = np.argsort(xi_ell)
    ax2.plot(xi_ell[si], kappa_nn[si], "o", color="C0", ms=5, label="MC")

    # HT model curve (same betas mapped to xi_2D/ell)
    xi_ell_fine = xi_2d_fine_cond / M
    sif = np.argsort(xi_ell_fine)
    ax2.plot(xi_ell_fine[sif], kappa_ht_fine[sif],
             "-", color="C3", lw=1.5, label="Leading-order HT")

    # Power-law fit in EFT regime
    p_cond = None
    eft = (xi_ell > 0.1) & (xi_ell < 1.0) & (kappa_nn > 1e-6)
    if np.sum(eft) >= 3:
        c = np.polyfit(np.log(xi_ell[eft]), np.log(kappa_nn[eft]), 1)
        p_cond = c[0]
        xr = np.logspace(np.log10(0.03), np.log10(10), 200)
        ax2.plot(xr, np.exp(c[1]) * xr**p_cond, ":", color="C2", lw=1.5,
                 label=rf"Fit: $\kappa \propto (\xi/\ell)^{{{p_cond:.1f}}}$")
        print(f"  Conductance power-law (EFT regime): "
              f"kappa ~ (xi/ell)^{p_cond:.2f}")

    ax2.set_xlabel(r"$\xi/\ell$")
    ax2.set_ylabel(r"$\kappa_{\rm NN}$")
    ax2.set_title(r"Mean NN conductance vs $\xi/\ell$")
    ax2.set_xscale("log")
    ax2.set_yscale("log")
    ax2.legend(fontsize=9, loc="upper left")
    ax2.grid(True, alpha=0.3)
    fig.tight_layout()
    fig.savefig(os.path.join(FIGDIR, "ising_crossover_conductance.pdf"))
    plt.close(fig)
    print("  Saved ising_crossover_conductance.pdf")

    # --- Figure 3: KEY PLOT -- Non-locality ratio vs xi_2D/ell ---
    fig, ax = plt.subplots(figsize=(7, 5))

    x_all = xi_ell[reliable]
    y_all = R_axis[reliable]
    si = np.argsort(x_all)
    x_all = x_all[si]; y_all = y_all[si]

    # At low xi/ell, kappa_NNN is below MC noise floor.
    # With xi_2D, the noise floor is at xi/ell ~ 0.20.
    NOISE_CUT = 0.20
    above = x_all >= NOISE_CUT
    below = x_all < NOISE_CUT

    # Noise-dominated points: dimmed
    if np.any(below):
        ax.plot(x_all[below], y_all[below], "o", color="C0", ms=5,
                alpha=0.25, zorder=3)
        nf_level = np.median(y_all[below])
        ax.axhspan(nf_level * 0.3, nf_level * 3, alpha=0.06, color="C0",
                    zorder=1)
        ax.text(x_all[below].min(), nf_level * 4, "MC noise floor",
                fontsize=8, color="C0", alpha=0.5, va="bottom")

    # Signal-dominated points
    ax.plot(x_all[above], y_all[above], "o", color="C0", ms=7, zorder=5,
            label=r"$R = \kappa_{\rm NNN}/\kappa_{\rm NN}$")

    # Analytical prediction: R = exp(-2 ell/xi) using exact Onsager xi
    # This is the zero-parameter prediction from the general framework:
    # block-block correlation C(d) ~ exp(-d*ell/xi), so
    # R = C(2ell)^2 / C(ell)^2 = exp(-2*ell/xi).
    xr_anal = np.logspace(np.log10(0.15), np.log10(8.0), 300)
    R_pred = np.exp(-2.0 / xr_anal)
    ax.plot(xr_anal, R_pred, "-", color="C3", lw=2.0,
            label=r"$e^{-2\ell/\xi}$ (zero-parameter)", zorder=4)

    # Power-law fit in EFT regime
    x_sig = x_all[above]
    y_sig = y_all[above]
    eft = x_sig < 1.0
    alpha_fit = None
    if np.sum(eft) >= 3:
        lx, ly = np.log(x_sig[eft]), np.log(y_sig[eft])
        c = np.polyfit(lx, ly, 1)
        alpha_fit = c[0]
        A_fit = np.exp(c[1])
        print(f"\n  Power-law fit (signal, xi/ell < 1.0): "
              f"R ~ {A_fit:.4e} * (xi/ell)^{alpha_fit:.3f}")

    ax.axvline(1.0, ls="--", color="gray", lw=1, alpha=0.5)
    ax.text(0.92, 1.5, r"$\xi = \ell$", fontsize=10, color="gray",
            ha="right")

    ax.set_xlabel(r"$\xi / \ell$")
    ax.set_ylabel(r"Non-locality ratio $R$")
    ax.set_title("HDA remainder vs correlation length")
    ax.set_xscale("log")
    ax.set_yscale("log")
    ax.set_ylim(1e-4, 3.0)
    ax.legend(loc="lower right", fontsize=9)
    ax.grid(True, alpha=0.3)
    fig.savefig(os.path.join(FIGDIR, "ising_crossover_remainder.pdf"))
    plt.close(fig)
    print("  Saved ising_crossover_remainder.pdf")

    # --- Figure 4: Anisotropy ---
    fig, ax = plt.subplots(figsize=(6, 4.5))
    x = xi_ell[reliable]; y = aniso[reliable]
    si = np.argsort(x)
    ax.plot(x[si], y[si], "o-", color="C0", ms=6,
            label=(r"$|\kappa_h - \kappa_v|"
                   r"/(\kappa_h + \kappa_v)$"))
    ax.axvline(1.0, ls="--", color="gray", lw=1, alpha=0.7)
    ax.axhline(0, ls="-", color="black", lw=0.5)
    ax.set_xlabel(r"$\xi / \ell$")
    ax.set_ylabel("Conductance anisotropy")
    ax.set_title(r"Isotropy of emergent co-metric vs $\xi/\ell$")
    ax.set_xscale("log")
    ax.legend(loc="upper left", fontsize=9)
    ax.grid(True, alpha=0.3)
    fig.savefig(os.path.join(FIGDIR, "ising_crossover_isotropy.pdf"))
    plt.close(fig)
    print("  Saved ising_crossover_isotropy.pdf")

    return alpha_fit, p_cond


def main():
    datapath = os.path.join(DATADIR, "ising_crossover_results.pkl")
    if not os.path.exists(datapath):
        print(f"Error: {datapath} not found.")
        print("Run ising_crossover.py first to generate the data.")
        sys.exit(1)

    print(f"Loading data from {datapath} ...")
    with open(datapath, "rb") as f:
        results = pickle.load(f)

    print(f"  {len(results)} temperature points loaded")

    print("\nGenerating figures ...")
    alpha, p_cond = make_plots(results)

    if alpha is not None:
        print(f"\n  RESULT: Remainder power-law exponent alpha = {alpha:.3f}")
    if p_cond is not None:
        print(f"  RESULT: Conductance power-law exponent p = {p_cond:.3f}")
    print(f"\nFigures saved to: {FIGDIR}")


if __name__ == "__main__":
    main()
